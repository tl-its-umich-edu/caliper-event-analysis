
# coding: utf-8

# # Visualizing Caliper Events in Python<br />With `pandas` and `numpy`
# > ðŸ’¡This notebook requires a few Python modules in addition to the common ones.  See the ["Prerequisites" section](#Prerequisites) at the end of this notebook for more information, especially if you see error messages or the notebook doesn't run correctly.
# 
# ## Introduction
# 
# This notebook reads Caliper events that were generated by an application.  For each course, it graphs the number of events that were found for each hour of the day, day of the week, and day of the year.
# 
# It was written to work with Caliper v1.0 events generated by the Problem Roulette (v1.0) application.  However, it may work with other event data JSON that contains "`.eventTime`" and "`.group.name`" attributes.

# ## Configuration
# 
# The values of the variables in the cell below may be changed to specify the locations of the input data and output visualizations and other options.

# In[1]:


# Path to input data file.
path = '../../tmp/pr.jsonl'

# Is the input JSONL (JSON Lines)? (If False, input will be treated as plain JSON)
# The JSONL format (AKA NDJSON, newline-delimited JSON) contains complete JSON objects
# separated only by line breaks (newline or carriage return)
jsonlInput = True

# Output to PDF?  (If False, display output inline with Jupyter Notebook)
pdfOutput = True

# Name of PDF output file.  (Ignored if pdfOutput == False)
pdfFilename = 'events.pdf'


# ## Initialization
# Load the various Python modules needed.

# In[2]:


import numpy as np
import gzip
from datetime import datetime
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import pandas as pd

if (jsonlInput):
    import ndjson as json
else:
    import json


# ## Load the JSON Input Data File
# This automatically supports files that have been compressed with `gzip`.

# In[3]:


try:
    with gzip.open(path, 'rt') as gid:
        all_recs = json.load(gid)
except OSError:
    with open(path, 'r') as gid:
        all_recs = json.load(gid)

print('Loaded {} records.'.format(len(all_recs)))


# ## Extract Data From Caliper Events

# In[4]:


# Format of ISO 8601 timestamps (for datetime.strptime)
iso8601TimestampFormat = '%Y-%m-%dT%H:%M:%S.%fZ'

# Extract some fields for each event; agg is a map from course names
# to event time stamps, the event times are split into columns
# according to the time.struct_time fields:
# https://docs.python.org/3/library/time.html#time.struct_time
agg = []
tfields = ['tm_hour', 'tm_mday', 'tm_min', 'tm_mon', 'tm_wday', 'tm_yday', 'tm_year']

for js in all_recs:
    # Extract the user id, but not currently used here
    if 'actor' not in js or js['actor'] is None:
        continue
    actor = js['actor']
    user_url = actor['@id']
    user = user_url.split(':')
    if len(user) < 3:
        continue

    # Extract the course name
    if 'group' not in js or js['group'] is None:
        continue
    course = js['group']['name']
    
    # Extract the time
    etime = js['eventTime']
    etime = datetime.strptime(etime, iso8601TimestampFormat)
    etime = etime.timetuple()
    etime = [getattr(etime, x) for x in tfields]
    etime.append(course)
    agg.append(etime)

agg = pd.DataFrame(agg)
agg.columns = tfields + ['course']


# ## Produce Visualizations

# In[5]:


if (pdfOutput):
    pdf = PdfPages(pdfFilename)
else:
    get_ipython().run_line_magic('matplotlib', 'inline')
    get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'svg'")
        
xlabels = {'tm_wday': 'Day of week', 'tm_yday': 'Date', 'tm_hour': 'Hour'}

for course, mat in agg.groupby('course'):

    # Three types of plots: by day, by weekday, and by hour
    for col in 'tm_yday', 'tm_wday', 'tm_hour':

        vc = mat[col].value_counts().sort_index()

        if col == 'tm_yday':
            d = [datetime.fromordinal(x) for x in vc.index]
        else:
            d = vc.index.tolist()

        ax = plt.axes()

        if col == 'tm_wday':
            ax.xaxis.set_ticks([0, 1, 2, 3, 4, 5, 6])
            ax.xaxis.set_ticklabels(['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'])
            ax.set_xlim(-0.2, 6.2)
        elif col == 'tm_yday':
            months = mdates.MonthLocator()
            days = mdates.DayLocator(bymonthday=[1, 7, 14, 21, 28])
            months_fmt = mdates.DateFormatter('%b')
            ax.xaxis.set_major_locator(months)
            ax.xaxis.set_minor_locator(days)
            ax.xaxis.set_major_formatter(months_fmt)
        elif col == 'tm_hour':
            ax.xaxis.set_ticks(range(0, 24, 3))

        ax.set_title(course)
        ax.grid(True)
        ax.set_xlabel(xlabels[col])

        ax.plot(d, vc.values, '-', color='grey')
        ax.plot(d, vc.values, 'o', color='orange', alpha=0.8)

        ax.set_ylabel('Records', size=15)
        
        if (pdfOutput):
            pdf.savefig()
        else:
            plt.show()
            
        plt.clf()

if (pdfOutput):        
    result = pdf.close()


# > ðŸ’¡If the graphs aren't shown neatly above, click on the gray area that appears in the left margin when you move the pointer over it.
# 
# > ðŸ™Unfortunately, preventing the "`matplotlib.figure.Figure`â€¦" output when the program ends has been difficult.  A solution is being sought.  It's safe to ignore the single line of output that appears.

# ----
# ## Prerequisites
# 
# This notebook requires the following modules:
# 
# * [`numpy`](https://pypi.org/project/numpy/) &ndash; The fundamental package for scientific computing with Python.
# * [`matplotlib`](https://pypi.org/project/matplotlib/) &ndash; A plotting library for Python and its numerical mathematics extension NumPy.
# * [`pandas`](https://pypi.org/project/pandas/) &ndash; Provides high-performance, easy-to-use data structures and data analysis tools.
# * [`ndjson`](https://pypi.org/project/ndjson/) &ndash;
#   A module for handling newline-delimited JSON.
# 
# > ðŸ’¡If this notebook fails to run because some of the required modules are not installed, click the "Install Modules" button below the following cell to try to install the modules. (If the button isn't shown, then run the cell to make it appear.)
# > 
# > After installing modules, you need to restart the kernel for this notebook before continuing.

# In[6]:


import ipywidgets

def installModules(click):
    import sys
    get_ipython().system('{sys.executable} -m pip install numpy matplotlib pandas ndjson')

button = ipywidgets.Button(description='Install Modules', button_style='success', icon='download')
button.on_click(installModules)
button

